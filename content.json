{"meta":{"title":"iqhy's Blog","subtitle":null,"description":null,"author":"iqhy","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-10-28T08:11:52.236Z","updated":"2019-10-28T08:11:52.236Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 Page 404 找不到页面 返回上一页 返回首页"},{"title":"","date":"2019-10-28T08:09:04.522Z","updated":"2019-02-14T22:23:50.000Z","comments":true,"path":"404_css/style.css","permalink":"http://yoursite.com/404_css/style.css","excerpt":"","text":"body { background-color: #2F3242; } svg { position: absolute; top: 50%; left: 50%; margin-top: -250px; margin-left: -400px; } .message-box { height: 200px; width: 380px; position: absolute; top: 50%; left: 50%; margin-top: -100px; margin-left: 50px; color: #FFF; font-family: Roboto; font-weight: 300; } .message-box h1 { font-size: 60px; line-height: 46px; margin-bottom: 40px; } .buttons-con .action-link-wrap { margin-top: 40px; } .buttons-con .action-link-wrap a { background: #68c950; padding: 8px 25px; border-radius: 4px; color: #FFF; font-weight: bold; font-size: 14px; transition: all 0.3s linear; cursor: pointer; text-decoration: none; margin-right: 10px } .buttons-con .action-link-wrap a:hover { background: #5A5C6C; color: #fff; } #Polygon-1 , #Polygon-2 , #Polygon-3 , #Polygon-4 , #Polygon-4, #Polygon-5 { -webkit-animation: float 1s infinite ease-in-out alternate; animation: float 1s infinite ease-in-out alternate; } #Polygon-2 { -webkit-animation-delay: .2s; animation-delay: .2s; } #Polygon-3 { -webkit-animation-delay: .4s; animation-delay: .4s; } #Polygon-4 { -webkit-animation-delay: .6s; animation-delay: .6s; } #Polygon-5 { -webkit-animation-delay: .8s; animation-delay: .8s; } @-webkit-keyframes float { 100% { -webkit-transform: translateY(20px); transform: translateY(20px); } } @keyframes float { 100% { -webkit-transform: translateY(20px); transform: translateY(20px); } } @media (max-width: 450px) { svg { position: absolute; top: 50%; left: 50%; margin-top: -250px; margin-left: -190px; } .message-box { top: 50%; left: 50%; margin-top: -100px; margin-left: -190px; text-align: center; } }"},{"title":"文章分类","date":"2019-10-28T07:29:43.000Z","updated":"2020-02-28T06:04:21.234Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-02-28T03:11:20.000Z","updated":"2020-02-29T08:57:52.328Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"作者：Yu Hanqing github: https://github.com/iqhy email: imyuhanqing@outlook.com"},{"title":"标签","date":"2019-10-24T15:22:28.000Z","updated":"2020-02-28T06:05:20.339Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"在 C++ 中调用 keras","slug":"在 C++ 中调用 keras","date":"2020-02-29T08:18:32.000Z","updated":"2020-02-29T08:44:53.603Z","comments":true,"path":"posts/2020/0229161832/","link":"","permalink":"http://yoursite.com/posts/2020/0229161832/","excerpt":"使用 frugally-deep 在 C++ 中轻松调用 Keras 模型","text":"使用 frugally-deep 在 C++ 中轻松调用 Keras 模型 Keras 使用起来非常方便，我们有时候需要在 C++ 中调用训练好的模型，希望在 C++ 中调用 Keras 的 model.predict()，但 Keras 并没有提供 C++ API。一种解决方法是使用 TensorFlow 的 C++ API，但编译过程非常繁琐，这里我们使用另一种方法，使用 Github 上的 frugally-deep。 介绍frugally-deep 是一个用 C++ 实现的库，简单易用，无需编译 TensorFlow，仅支持在 CPU 上运行。 支持的模型frugally-deep 支持大多数常用的模型 Add, Concatenate, Subtract, Multiply, Average, Maximum AveragePooling1D/2D, GlobalAveragePooling1D/2D Bidirectional, TimeDistributed, GRU, LSTM, CuDNNGRU, CuDNNLSTM Conv1D/2D, SeparableConv2D, DepthwiseConv2D Cropping1D/2D, ZeroPadding1D/2D BatchNormalization, Dense, Flatten Dropout, AlphaDropout, GaussianDropout, GaussianNoise SpatialDropout1D, SpatialDropout2D, SpatialDropout3D MaxPooling1D/2D, GlobalMaxPooling1D/2D ELU, LeakyReLU, ReLU, SeLU, PReLU Sigmoid, Softmax, Softplus, Tanh UpSampling1D/2D Reshape, Permute Embedding 以及 multiple inputs and outputs nested models residual connections shared layers variable input shapes arbitrary complex model architectures / computational graphs custom layers (by passing custom factory functions to load_model) 安装frugally-deep 的安装很简单，可以使用官方安装教程 INSTALL.md 上的命令安装，也可以直接下载源码。使用命令安装的方法已经很详细了，这里采用直接下载源码的方式。 frugally-deep 需要 支持 C++14 的编译器 Python 3.5 以上 TensorFlow 2.0.0 如果你正在使用 Tensorflow 1.x 的 keras，安装 TensorFlow 2.0.0 后大多数情况下只需要把 import keras 修改为 import tensorflow.keras 即可 下载源码分别前往frugally-deep, FunctionalPlus , Eigen 和 json 点击右侧的 Clone or download 再点击 Download ZIP 下载这些源码。 解压假设现在的代码根目录下的源文件只有 main.cpp，文件结构： 1+-- main.cpp 将 frugally-deep 源码中的 include 文件夹和 keras_export 文件夹解压到与 main.cpp 相同的目录下： 1234+-- include| +-- fdeep+-- keras_export+-- main.cpp 将 FunctionalPlus 源码中 include 文件夹内的 fplus 文件夹复制到 main.cpp 相同目录下的 include 文件夹内： 12345+-- include| +-- fdeep| +-- fplus+-- keras_export+-- main.cpp 同样，将 json 源码中 include 文件夹内的 nlohmann 文件夹复制到 main.cpp 相同目录下的 include 文件夹内： 123456+-- include| +-- fdeep| +-- fplus| +-- nolhmann+-- keras_export+-- main.cpp 最后将 eigen 源码中 Eigen 文件夹放在 main.cpp 相同目录下的 include 文件夹内 1234567+-- include| +-- Eigen| +-- fdeep| +-- fplus| +-- nolhmann+-- keras_export+-- main.cpp 需要的文件已经安装完成，下面可以开始使用了。 使用使用 frugally-deep 的总体过程为： 在 Python 中训练好模型后，使用 model.save(&#39;....h5&#39;, include_optimizer=False) 保存模型 使用 keras_export/convert_model.py 将 .h5 模型转换成 C++ 模型 在 C++ 中使用 fdeep::load_model(...) 加载模型 在 C++ 中使用 model.predict(...) 调用模型 下面我们以 frugally-deep 主页 上的例子来说明如何使用。假设我们在 Python 中编写了模型 12345678910111213141516# create_model.pyimport numpy as npfrom tensorflow.keras.layers import Input, Densefrom tensorflow.keras.models import Modelinputs = Input(shape=(4,))x = Dense(5, activation='relu')(inputs)predictions = Dense(3, activation='softmax')(x)model = Model(inputs=inputs, outputs=predictions)model.compile(loss='categorical_crossentropy', optimizer='nadam')model.fit( np.asarray([[1, 2, 3, 4], [2, 3, 4, 5]]), np.asarray([[1, 0, 0], [0, 0, 1]]), epochs=10)model.save('keras_model.h5', include_optimizer=False) 模型保存后，使用下面的命令进行转换 1python keras_export/convert_model.py keras_model.h5 fdeep_model.json 看到下面这些就是转换成功了 12345678910111213141516Forward pass took 0.091729 s.Forward pass took 0.038896 s.Forward pass took 0.077791 s.Starting performance measurements.Forward pass took 0.037899 s.Forward pass took 0.037896 s.Forward pass took 0.043883 s.Forward pass took 0.038922 s.Forward pass took 0.042861 s.Forward pass took 0.04029220000000001 s on average.Converting model architecture.Converting model weights.Done converting model weights.Calculating model hash.Model conversion finished.writing fdeep_model.json 转换过程中，frugally-deep 会自动对模型进行测试，验证相同的输入数据下 Python 和 C++ 的输出是否相同。 转换完成后，在 C++ 中进行调用 12345678910// main.cpp#include &lt;fdeep/fdeep.hpp&gt;int main()&#123; const auto model = fdeep::load_model(\"fdeep_model.json\"); const auto result = model.predict( &#123;fdeep::tensor(fdeep::tensor_shape(static_cast&lt;std::size_t&gt;(4)), &#123;1, 2, 3, 4&#125;)&#125;); std::cout &lt;&lt; fdeep::show_tensors(result) &lt;&lt; std::endl;&#125; 这时，以 Visual Studio 为例，编译器会报错 1fatal error C1083: 无法打开包括文件: “fdeep/fdeep.hpp”: No such file or directory 这是因为还没有添加附加包含目录，右键点击“解决方案资源管理器”中的项目名称，选择属性 -&gt; 配置属性 -&gt; C/C++ -&gt; 常规，在右侧的附加包含目录中填上 $(ProjectDir)include; 若使用的是 gcc 编译器，要在编译时加上参数 -Iinclude 再次运行 main.cpp，输出： 12345Loading json ... done. elapsed time: 0.009921 sBuilding model ... done. elapsed time: 0.018725 sRunning test 1 of 1 ... done. elapsed time: 0.003242 sLoading, constructing, testing of fdeep_model.json took 0.038064 s overall.[[[[[[[0.7297, 0.1624, 0.1078]]]]]]] 调用成功。另外，model.predict 是线程安全的，可以在不同线程中直接调用。 常见问题model.predict() 的数据类型frugally-deep 使用的数据类型是 fdeep::tensor，下面的例子说明了如何声明一个 fdeep::tensor 并初始化 1234// tensor的形状参数在fdeep::tensor_shape()中，0是初始化的值fdeep::tensor tensor_a(fdeep::tensor_shape(3, 8, 3), 0);// 将tensor_a[0][1][2]位置的值置1tensor_a.set(fdeep::internal::tensor_pos(0, 1, 2), 1); 有了 fdeep::tensor 我们可能会需要将其转化为 std::vector 进行后续的操作 12// 将tensor_a转为std::vectorconst std::vector&lt;float&gt; vec = *tensor_a.as_vector(); 除此之外，其他的方法可以参考官方 FAQ.md。要注意，frugally-deep 中必须采用 channel-last 的格式。 error C2653:使用 Visual Studio 2019 时可能会遇到这个问题 1error C2653: &apos;FOut&apos;: is not a class or namespace name 这是一个编译器 BUG，详见 Github issue ，目前已经在 16.5 Preview 2 版本中修复，解决方法是使用 Visual Studio 预览版或 Visual Studio 2017。 fdeep::model 没有默认构造函数当使用 fdeep::model 作为类的成员变量时，会遇到 fdeep::model 没有默认构造函数 的问题，这是作者刻意为之的，解决方法是使用std::unique_ptr&lt;fdeep::model&gt; 下面的例子说明了如何使用 1234567891011121314// neural_network.h#pragma once#include &lt;fdeep/fdeep.hpp&gt;class NeuralNetwork&#123;private: std::unique_ptr&lt;fdeep::model&gt; model;public: NeuralNetwork(); fdeep::tensors predict(fdeep::tensor&amp; feature_planes);&#125;; 123456789101112// neural_network.cpp#include \"neural_network.h\"NeuralNetwork::NeuralNetwork()&#123; this-&gt;model = std::make_unique&lt;fdeep::model&gt;(fdeep::load_model(\"fdeep_model.json\"));&#125;fdeep::tensors NeuralNetwork::predict(fdeep::tensor&amp; data)&#123; return this-&gt;model-&gt;predict(&#123; data &#125;);&#125; 运行速度比 Python 慢 100 倍Visual Studio 要使用 “Release” 模式，gcc 要开启 -O3 优化。参考FAQ.md 总结如果你需要在 C++ 中调用 model.predict() 且没有使用 GPU 的需求，frugally-deep 是一个很好的选择。 还想了解更多可以阅读官方的英文资料 frugally-deep 参考资料 https://github.com/Dobiasd/frugally-deep","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"keras","slug":"keras","permalink":"http://yoursite.com/tags/keras/"}]},{"title":"Python 调用 C++","slug":"Python 调用 C++","date":"2020-02-28T07:56:01.000Z","updated":"2020-02-29T04:49:34.609Z","comments":true,"path":"posts/2020/0228155601/","link":"","permalink":"http://yoursite.com/posts/2020/0228155601/","excerpt":"Python 的代码优雅而实用，但是经常会遇到性能问题，这时可以使用 C/C++ 重写几个函数来解决，这样就同时兼顾了开发效率和性能。","text":"Python 的代码优雅而实用，但是经常会遇到性能问题，这时可以使用 C/C++ 重写几个函数来解决，这样就同时兼顾了开发效率和性能。 本文使用分为3个部分 安装 Cython (注意区别 CPython) Python 调用 C++ 函数 Python 调用 C++ 类 安装 Cython安装 Cython 最简单方法的是使用： pip install cython 或 conda install cython 与 Python 不同，Cython 编写的程序要先编译才能执行，因此，Cython 要求系统中有 C 编译器，在Windows 中使用 MinGW (gcc) 和 Visual Studio 的编译器均可。 Python 调用 C/C++ 函数编写一个 Python 函数以一个简单的函数为例，在 Python 中编写如下函数来计算 $tanh(x)$ 的值 1234567891011121314151617181920from random import randomfrom time import timee = 2.7182818284590452353602874713527def sinh(x): return (1 - (e ** (-2 * x))) / (2 * (e ** -x))def cosh(x): return (1 + (e ** (-2 * x))) / (2 * (e ** -x))def tanh(x): return sinh(x) / cosh(x)data = [random() for i in range(1000000)] # 生成随机数据start_time = time() # 调用1000000次tanh函数并统计时间result1 = list(map(tanh, data))end_time = time()print(end_time - start_time) 运行该程序需要 1.39 秒，将上述函数改写成 C++，将其保存在 mytanh.cpp 中 123456789101112131415161718#include &lt;cmath&gt;const double e = 2.7182818284590452353602874713527; double mysinh(double x)&#123; return (1 - pow(e, (-2 * x))) / (2 * pow(e, -x));&#125;double mycosh(double x)&#123; return (1 + pow(e, (-2 * x))) / (2 * pow(e, -x));&#125;double mytanh(double x)&#123; return mysinh(x) / mycosh(x);&#125; 由于sinh, cosh, tanh是 C++ 库函数，这里修改一下函数名。 在 Cython 中声明该函数新建一个fast_tanh.pyx 文件，.pyx 是 Cython 代码的后缀名，文件内容如下。 12345678# distutils: language = c++# cython: language_level = 3cdef extern from &quot;mytanh.cpp&quot;: double mytanh(double x) def fast_tanh(double x): return mytanh(x) 其中 12# distutils: language = c++# cython: language_level = 3 是用于配置编译器的特殊注释，分说明了使用的是 C++ 和 Python3 12cdef extern from &quot;mytanh.cpp&quot;: double mytanh(double x) Cython 使用 cdef extern from 来声明一个在 C++ 中实现的函数。上述代码声明了 mytanh 函数，使其可以在 Cython中使用。 在 Cython 中编写接口函数虽然 mytanh 现在可以在 Cython 中直接调用了，但 Python 并不能直接调用该函数，因此还要声明一个接口函数，命名为 fast_tahn。 12def fast_tanh(double x): return mytanh(x) 上述代码声明了一个接口函数，Cython 的语法与 Python 非常相似，若去掉形参中的 double 也是可行的，但若 Cython 知道参数的类型可以加速运行速度。Cython 支持大部分纯 Python 代码，因此可以在 Cython 中将 Python 的数据类型和 C++ 的数据类型相互转换，例如可以将 vector 转为 numpy array。若要使用 vector 类型，还需在开头加上 from libcpp.vector cimport vector。 编写 setup.pyfast_tanh.pyx 编写完后，需要编译后才能被 Python 调用，编译是通过 setup.py 进行的。 12345678910111213from distutils.core import setup, Extensionfrom Cython.Build import cythonizesetup(ext_modules=cythonize(Extension( 'fast_tanh', # 生成的模块名称 sources=['fast_tanh.pyx'], # 要编译的文件 language='c++', # 使用的语言 include_dirs=[], # gcc的-I参数 library_dirs=[], # gcc的-L参数 libraries=[], # gcc的-l参数 extra_compile_args=[], # 附加编译参数 extra_link_args=[], # 附加链接参数))) 其他参数可以根据需要添加，如果你暂时还不知道这些参数有什么用，那么可以先空着。将上述代码保存到 setup.py 后，运行如下命令即可编译 Cython 文件。 1python setup.py build_ext --inplace 需要注意，编译时的 Python 版本必须和调用时使用的 Python 版本相同。编译完成后，当前目录下会自动生成相应的 cpp 文件和 pyd 文件，在 Linux 上是 so 文件。 如果使用了 numpy 会在编译过程中看到警告： 1Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION 该警告可以忽略，因为 Cython 使用的是已经弃用的 Numpy API，不影响使用。 在 Python 中调用 fast_tanh 函数完成了编译的步骤后，fast_tanh在 Python 中就和一个普通的 Python 模块一样，可以使用 import 来导入 1from fast_tanh import fast_tanh # 从fast_tanh.pyx中导入fast_tanh函数 导入后，就可以在 Python 中像调用普通函数一样，直接使用 fast_tanh 函数了，完整代码如下，与之前的区别仅仅是把 tanh 替换成了 tanh，非常方便。 12345678910from random import randomfrom time import timefrom fast_tanh import fast_tanhdata = [random() for i in range(1000000)] # 生成随机数据start_time = time() # 计算并统计时间result = list(map(fast_tanh, data))end_time = time()print(end_time - start_time) # 输出运行时间 运行上述代码共需 0.18 秒，可以看到，仅仅替换了一个 tanh 函数后性能提升了近 8 倍。如果有其他更复杂的操作，可以提升几十上百倍的性能。 Python 调用 C/C++ 类编写一个 C++ 类知道如何调用一个 C/C++ 函数后，接下来继续调用一个 C/C++ 类。我们以一个简单的矩形类为例，假设我们在 C++ 中编写了一个矩形类。头文件 Rectangle.h 为： 123456789101112131415161718#ifndef RECTANGLE_H#define RECTANGLE_Hnamespace shapes &#123; class Rectangle &#123; public: int x0, y0, x1, y1; // 矩形对角线上的两个点坐标 Rectangle(); Rectangle(int x0, int y0, int x1, int y1); ~Rectangle(); int getArea(); void getSize(int* width, int* height); void move(int dx, int dy); &#125;;&#125;#endif Rectangle.cpp 中的实现为： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include \"Rectangle.h\"namespace shapes &#123; // 构造函数 Rectangle::Rectangle () &#123;&#125; Rectangle::Rectangle (int x0, int y0, int x1, int y1) &#123; this-&gt;x0 = x0; this-&gt;y0 = y0; this-&gt;x1 = x1; this-&gt;y1 = y1; &#125; // 析构函数 Rectangle::~Rectangle () &#123;&#125; // 获取矩形面积 int Rectangle::getArea () &#123; return (this-&gt;x1 - this-&gt;x0) * (this-&gt;y1 - this-&gt;y0); &#125; // 获取矩形的边长 void Rectangle::getSize (int *width, int *height) &#123; (*width) = x1 - x0; (*height) = y1 - y0; &#125; // 移动矩形 void Rectangle::move (int dx, int dy) &#123; this-&gt;x0 += dx; this-&gt;y0 += dy; this-&gt;x1 += dx; this-&gt;y1 += dy; &#125;&#125; 在 Cython 中声明类接下来需要在 Cython 中编写一个接口。与前面调用 C++ 函数类似，使用 cdef extern from 来声明一个在 C++ 中实现的类： 1cdef extern from \"Rectangle.h\" namespace \"shapes\": 若没有命名空间，则使用： 1cdef extern from \"Rectangle.h\" 将声明放在 Rectangle.pxd 文件中，.pxd 文件相当于 C++ 的 .h 文件，专门用于声明： 1234567891011cdef extern from &quot;Rectangle.cpp&quot;: pass# 用cdef声明类cdef extern from &quot;Rectangle.h&quot; namespace &quot;shapes&quot;: cdef cppclass Rectangle: Rectangle() except + Rectangle(int, int, int, int) except + int x0, y0, x1, y1 int getArea() void getSize(int* width, int* height) void move(int, int) 由于 .h 文件中没有实现矩形类，还要使用 12cdef extern from &quot;Rectangle.cpp&quot;: pass 包含 Rectangle.cpp 中的代码 1cdef cppclass Rectangle: 声明了一个在 C++ 中定义的类，其他函数的声明与前面调用函数类似。在构造函数后加上 except + 可以使 Python 能够捕获到在构造函数中发生的异常，若不加 except +，则 Cython 不会处理构造函数中发生的异常。 在 Cython 中编写接口类与前面相同，虽然现在 C++ 中的类在 Cython 中可以直接访问了，但在 Python 中并不能访问。因此，我们还需要实现一个接口类，用于在 Python 中调用。注意，C++ 类的声明放在 .pxd 文件中, 接口类的实现放在 .pyx 中。PyRectangle.pyx为 : 1234567891011121314151617# distutils: language = c++from Rectangle cimport Rectangle# 接口类# Python可以直接访问接口类，接口类可以直接访问C++类cdef class PyRectangle: cdef Rectangle c_rect # 存储C++对象 def __cinit__(self, int x0, int y0, int x1, int y1): self.c_rect = Rectangle(x0, y0, x1, y1) def get_area(self): return self.c_rect.getArea() def get_size(self): cdef int width, height self.c_rect.getSize(&amp;width, &amp;height) return width, height def move(self, dx, dy): self.c_rect.move(dx, dy) 现在，PyRectangle 类就像普通的 Python 类一样可以直接在 Python 中调用了。 另外，Cython 也支持使用 new 创建 C++ 对象 12def __cinit__(self, int x0, int y0, int x1, int y1): self.c_rect = new Rectangle(x0, y0, x1, y1) 与 C++ 相同，使用了 new 就必须使用 delete 释放内存，否则会造成内存泄漏。 12def __dealloc__(self): # 析构函数 del self.c_rect # 释放内存 编译setup.py 内容如下 12345678910111213from distutils.core import setup, Extensionfrom Cython.Build import cythonizesetup(ext_modules=cythonize(Extension( 'PyRectangle', # 生成的模块名称 sources=['PyRectangle.pyx'], # 要编译的文件 language='c++', # 使用的语言 include_dirs=[], # gcc的-I参数 library_dirs=[], # gcc的-L参数 libraries=[], # gcc的-l参数 extra_compile_args=[], # 附加编译参数 extra_link_args=[], # 附加链接参数))) 使用 python setup.py build_ext --inplace 编译 在 Python 中调用接口类现在，PyRectangle 类就和普通的 Python 类一样，可以直接被 Python 调用 12345import PyRectanglex0, y0, x1, y1 = 1, 2, 3, 4rect = PyRectangle.PyRectangle(x0, y0, x1, y1)print(rect.get_area) 运行该程序，输出了矩形面积，调用成功。 总结通过 Cython 调用 C/C++ 的原理是： Python -&gt; Cython 接口 -&gt; C/C++ 访问 C++ 都是通过 Cython 接口完成的。 若还想了解更多，可以阅读 Cython 文档 参考资料 https://www.bookstack.cn/read/cython-doc-zh/README.md https://www.youtube.com/watch?v=D9RlT06a1EI&amp;t=45s","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"蒙特卡洛树搜索 MCTS 入门","slug":"蒙特卡洛树搜索 MCTS 入门","date":"2019-10-28T07:46:02.000Z","updated":"2020-02-28T16:01:52.619Z","comments":true,"path":"posts/2019/1028154602/","link":"","permalink":"http://yoursite.com/posts/2019/1028154602/","excerpt":"蒙特卡洛树搜索(Monte Carlo Tree Search) ，一种寻找最优决策的方法。","text":"蒙特卡洛树搜索(Monte Carlo Tree Search) ，一种寻找最优决策的方法。 【内容简介】蒙特卡洛树搜索(Monte Carlo Tree Search) 是一种寻找最优决策的方法，在AlphaGo中被运用，其主要分为四步：选择(Selection)，拓展(Expansion)，模拟(Simulation)，反向传播(Backpropagation)。 本文以井字棋为例对这一方法进行介绍。 基础知识节点在棋类问题中，MCTS 使用一个节点来表示一个游戏状态。若现在井字棋的棋盘上只有中间一个棋子，我们用一个节点表示这个游戏状态。那么，下一步棋有8种下法，所以对应的，刚才那个节点就有8个子节点(图中只画出了3个)，如下图所示。根据这个方法，这些子节点又有子节点，所有的井字棋游戏状态都可以被这样表示，于是它们就构成了一个树。蒙特卡洛树搜索就是要在这样一个树中搜索最可能获胜的游戏状态，即搜索最佳下棋策略。 节点的两个属性在蒙特卡洛树搜索中，节点记作$v$，且每个节点都有如下属性。 $N(v)$：节点$v$的访问次数，节点被访问多少次，该值就是多少。 $Q(v)$：节点$v$的累计奖励，即节点在反向传播过程中所有奖励的和。 这两个属性会在下面的过程中用到，并会详细说明。 搜索过程那么，给定当前游戏状态，如何获得下一步的最佳下法呢？对于井字棋来说，当然可以遍历所有可能性，直接找出最优策略。但若换成围棋等复杂的棋类，遍历的方法显然不可行。下面就是蒙特卡洛树搜索的核心部分。 选择(Selection)选择阶段，从根节点(给定的游戏状态)出发，根据一定的策略，向下选择一个节点，若被选择的节点未被访问，则执行扩展；若被选择的节点已被访问，则继续向下选择节点，直到遇见未被访问的节点并执行扩展，或遇见终止节点(游戏结束)，无需执行扩展，而直接执行反向传播。 这个选择的策略由该公式确定，对于当前节点的每个子节点计算如下公式，并选择结果最大的节点。$$\\underset{v’\\in ,,\\text{children of }v}{arg\\max}\\frac{Q\\left( v’ \\right)}{N\\left( v’ \\right)}+c\\sqrt{\\frac{\\text{2}\\ln N\\left( v \\right)}{N\\left( v’ \\right)}}$$其中， $v$ 表示父节点，$v’$ 表示子节点。$c$是一常数，用于权衡探索 (Exploration) 与利用 (Exploitation)。$c$越大，算法就越偏向于探索访问次数少的节点；$c$越小，算法就越偏向于选择获胜可能性高的节点，称为利用。 扩展 (Expansion)扩展非常简单，就是把选择步骤中遇到的未访问节点添加到现有的树中。 模拟 (Simulation)从被扩展的节点开始，让游戏随机进行，也就是在棋盘上随机下棋，直到游戏结束。若此时游戏胜利，则奖励 (Reward) 为$1$；若游戏失败，奖励为$-1$。这个奖励会在反向传播中被用到。 注：在其他应用中，奖励也可是其他值。 反向传播 (Backpropagation)反向传播其实就是对执行模拟的节点或终止节点的所有父节点的两个属性进行逐一更新的过程。 将奖励记作$R$，对所有节点$v$，包括当前节点，都执行以下操作。$$N(v)=N(v)+1 \\\\Q(v)=Q(v)+R$$我们再回头看看选择步骤中的公式$$\\underset{v’\\in ,,\\text{children of }v}{arg\\max}\\frac{Q\\left( v’ \\right)}{N\\left( v’ \\right)}+c\\sqrt{\\frac{\\text{2}\\ln N\\left( v \\right)}{N\\left( v’ \\right)}}$$可以看到，式中第一项其实就是该节点在前面的过程中获得的平均奖励，自然该值越大，选择该节点就越有可能获胜。那么为什么要加上第二项呢？这就涉及到探索与利用的权衡。 我们不能只选择已访问过的节点中平均奖励最大的节点，一些访问次数较少的、甚至没有访问过的节点它们可能获得比已探索的节点更丰厚的回报，因此也要适当地在未知的节点进行探索。这就是第二项的含义，当该节点访问次数占父节点次数的比例越小时，该值越大，代表我们越要在此节点进行探索。于是就不难理解$c$用于是权衡探索与利用的常数了。 这就是上限置信区间算法 (Upper Confidence Bound )，简称UCT算法。 搜索过程展示看完了这四个步骤，我们再来看一张动图帮助理解。图中节点内数字表示 $Q(v)/N(v)$ 搜索结束MCTS的整个搜索过程就是这样，那么什么时候结束呢？一般设置以下两个终止条件。 设置最大根节点搜索次数，达到该次数后结束搜索。 设置最大搜索时间，超过时间后结束搜索。 选择最佳节点搜索结束后，选择哪个节点作为下一步的选择呢？ 不是选择$Q$最大的节点，也不是选择平均奖励最大的节点，而是选择访问次数最多的节点。这样，就得到了当前游戏状态(根节点)下的一个选择。 如果下一步还要进行决策，则又要将下一步的状态作为根节点，重新执行MCTS搜索，并选择访问次数最多的节点作为下一步的策略。(上一步的搜索结果可以保留) 以上只是 MCTS 的简单介绍，想更详细的了解 MCTS 可以参考论文A Survey of Monte Carlo Tree Search Methods 另外，Github 上也已经有 MCTS 的 Python 实现源码 https://github.com/pbsinclair42/MCTS","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"mcts","slug":"mcts","permalink":"http://yoursite.com/tags/mcts/"}]}]}